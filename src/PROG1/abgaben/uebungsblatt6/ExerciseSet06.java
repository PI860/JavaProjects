package PROG1.abgaben.uebungsblatt6;

import PROG1.Terminal;

import java.util.Random;
import java.util.Scanner;

/**
 * @author Paulina Pyczot
 **/


public class ExerciseSet06 {

    public static Scanner scanner = new Scanner(System.in); // this way the scanner can be used in every method without having to create it again
    public static final String DEFAULT_PROMPT = "Bitte Wert eingeben: ";

    public static void main(String[] args) {
        int menu = 1;
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        double numD1 = 0;
        double numD2 = 0;
        String s1 = null;
        String s2 = null;

        do {
            menu = Terminal.readInt("Choose menu: \n1: Random number generator and sorter \n2: Game: Guess the Number \n3: Pattern finder \n4: Tour planner \n0: Esc \nType in the number of the menu of your choice");
            System.out.println();
            switch (menu) {
                case 1:
                    // Aufgabe 1:
                    System.out.println("**** 1: Random number generator and sorter ****");
                    generateRandomNumber(num1, num2, num3);
                    break;
                case 2:
                    // Aufgabe 2:
                    System.out.println("**** 2: Game: Guess the Number ***");
                    guessTheNumber(num1, num2);
                    break;
                case 3:
                    // Aufgabe 3 (Umgang mit der Klasse String):
                    System.out.println("**** 3: Pattern finder ****");
                    find(s1, s2);
                    break;
                case 4:
                    // Aufgabe 4 (Tourenplaner):
                    System.out.println("**** 4: Tour planner ****");
                    getData(num1,numD1,numD2);
                    break;
                case 0:
                    break;
            }
        } while (menu != 0);
        scanner.close();
    }

    /**
     * Aufgabe 1:
     * Generates random numbers in a specific number area, saves them in an array, sorts them by using insertion sort and puts them out.
     * Tests are in attached excel file.
     * @param size defines the size of the array
     * @param min  defines the minimum value of the area
     * @param max  defines the maximum value of the area
     * @return
     */
    public static int generateRandomNumber(int size, int min, int max) {
        Random random = new Random();
        System.out.println("Type in the min. area of random numbers: ");
        min = scanner.nextInt();
        System.out.println("Type in the max. area of random numbers: ");
        max = scanner.nextInt();
        System.out.println("Type in how many numbers you want to be generated: ");
        size = scanner.nextInt();

        // Generates random numbers and saves them to array:
        int array[] = new int[size];
        System.out.println("Unsorted random numbers: ");
        for (int i = 0; i < size; i++) {
            int number = random.nextInt(max - min + 1) + min; // generates random numbers between min and max
            System.out.print(number + "|"); // Test: does the output of random numbers work?
            array[i] = number;
        }
        System.out.println();
        // Sorts the saved numbers in array via insertion sort:
        for (int i = 0; i < size; i++) { //i = marks the beginning of the unsorted area
            int insertVal = array[i];
            int insertPos = i;
            // Determines the next insertion position:
            while (insertPos > 0 && array[insertPos - 1] > insertVal) {
                array[insertPos] = array[insertPos - 1];
                insertPos--;
            }
            array[insertPos] = insertVal;
        }
        // Output of the saved numbers in array sorted by size in ascending order:
        System.out.println("Sorted same numbers: ");
        for (int i = 0; i < size; i++) {
            System.out.print(array[i] + "|");
        }
        System.out.println();
        System.out.println();
        return 0;
    }

    /**
     * Aufgabe 2:
     * Generates a random number the user has to find out in 3 attempts.
     * @param area defines the range the user has to guess in (e.g. 100 for the numbers between 0 and 100)
     * @param randomNumber defines a random number which is generated by the program
     * @return Perfect guess strategy:
     * In every attempt guess the half of the range ((max-min)/2).
     * If the program tells you to guess a bigger number, take your guessed number as the new minimum.
     * If the program tells you to guess a smaller number, take your guessed number as the new maximum.
     * Now guess the half of the range with new min or new max again.
     * Pseudocode for a range between 0 and 10 (you will need more attempts the higher your maximum is set):
     * int min = 0;
     * int max = 10;
     * for (int attempts; attempts < 3; attempts++) {
     * int guess = (max-min)/2;
     * read output;
     * if (output == "smaller") {
     * max = guess; // new max
     * } else {
     * min = guess; // new min
     * }
     * }
     * Run:
     * randomNumber = 4;
     * Loop:
     * guess = 5;
     * Output: Wrong! The number we're searching for is smaller.
     * guess = 3; // 2.5 rounded to int
     * Output: Wrong! The number we're searching for is bigger.
     * guess = 4;
     * Output: Congratulations, you guessed right!
     */
    public static int guessTheNumber(int area, int randomNumber) {
        Random random = new Random(); // Implement random class to generate a random number
        System.out.println("Please provide the area of numbers you want to guess in (e.g. 100 for the numbers between 0 and 100): ");
        area = scanner.nextInt(); // sets the given number as maximum range
        randomNumber = random.nextInt(area);
        //System.out.println(randomNumber); // Test: which random number was created by the computer?

        System.out.println("The computer found a random number between 0 and " + area + ".");

        for (int attempts = 0; attempts < 3; attempts++) {
            System.out.println("Guess the right number in " + (3 - attempts) + " attempts: ");
            int inputUser = scanner.nextInt();
            if (inputUser > randomNumber) {
                System.out.println("Wrong! The number we're searching for is smaller. ");
            } else if (inputUser < randomNumber) {
                System.out.println("Wrong! The number we're searching for is bigger. ");
            } else if (inputUser == randomNumber) {
                System.out.println("Congratulations, you guessed right!");
                break;
            }
        }
        System.out.println("Game finished.");
        System.out.println();
        return 0;
    }

    /**
     * Aufgabe 3:
     * Searches for the first occurrence of pattern in text and returns its position.
     * If no match is found, -1 is returned.
     * Examples: find("abcdcd", "cd") == 2
     * find("abcdcd", "e") == -1
     * This is a collaboration work.
     * @param text
     * @param pattern
     * @return
     */
    public static int find(String text, String pattern) {
        System.out.println("Provide a text: ");
        text = scanner.nextLine();
        System.out.println("Length of text: " + text.length());
        System.out.println("Provide the pattern you are searching for: ");
        pattern = scanner.nextLine();
        System.out.println("Length of text: " + pattern.length());
        System.out.println();

        // Version 1 (pattern finder does not work for texts which consist of 2 same following characters, e.g. text: "Ich heiße Paula", search for pattern: "heiße" -> output -1 (program only sees the first "h" in "Ich", the loop doesn't work then)
//        Tests:
//        System.out.println(text.length());
//        System.out.println(pattern.length());
//        System.out.println(text.charAt(1)); // Test: text.charAt(1) -> text = "abcd" -> output: b
//        System.out.println("Pattern found at position: ");
//        int i, j; // i counts the text index, j counts the pattern index
//        boolean k = true;
//        for (i = 0, j = 0; i < text.length(); i++) {
//            if (text.charAt(i) == pattern.charAt(j)) { // Checks if the first digit in pattern is somewhere in the text
//                // If there's one digit in text = pattern, it checks if the next digit out of the text is the same as the next digit in the given pattern:
//                i++;
//                for (j = 1; pattern.length()-1 >= j; i++, j++) { // Checks all next digits in pattern as long as the digits in the pattern didn't end yet
//                    if (text.charAt(i) == pattern.charAt(j) && pattern.length() > j && k == true) {
//                        if (pattern.length() - 1 == j) {
//                            System.out.println(i-j);
//                            // Print the position of the text counter i at the very end of j (when all digits of j has been iterated)
//                        } else if (k == false) {
//                            System.out.println("-1"); // Print error if one of the digits in text isn't contained in the pattern
//                        }
//                    } else {
//                        k = false;
//                        System.out.println("-1");
//                    }
//                }
//                break;
//            } else if (i == text.length()-1 || j != 0) {
//                System.out.println("-1"); // Print error if no digit in text is contained in pattern
//            }
//            j = 0;
//        }

        // Version 2:
        int occurance = 0;
        boolean found = false;

        for (int textIndex = 0; textIndex < text.length(); textIndex++) {
            for (int patternIndex = 0; patternIndex < pattern.length() && textIndex + patternIndex < text.length(); patternIndex++) {
                if (text.charAt(textIndex + patternIndex) == pattern.charAt(patternIndex)) {
                    occurance++;
                    if (occurance == pattern.length() && !found) {
                        System.out.println("Pattern found at position: " + textIndex);
                        found = true;
                    }
                }
            }
            occurance = 0;
        }
        if(!found)
        System.out.println("-1");

        System.out.println();
        return 0;
    }

    // Aufgabe 4 (Tourenplanung):
    public static String[] namePlaceData = new String[20];
    public static String[] namePlaceDataFinal = {"Angeregg", "Hanslettalm", "Wiedersberger_Horn","Hanslettalm","Angeregg"};
    public static int[] heightData = new int[20];
    public static int[] heightDataFinal = {950, 1616, 2127,1616,950};
    public static double[] distanceFromStartData = new double[20];
    public static double[] distanceFromStartDataFinal = {0, 3.5, 5,7.5,10};
    public static double verticalUpwardSpeed = 300;
    public static double verticalDownwardSpeed = 500;
    public static double horizontalSpeed = 4;
    public static double[] horizontalTimeData = new double[20];
    public static double[] verticalTimeData = new double[20];
    public static double[] timeData = new double[20];
    public static int[] hoursData = new int[20];
    public static double[] minutesData = new double[20];

    public static int places = 3;

    /**
     * Aufgabe 4 (Tourenplanung):
     * Scans number of places, names, heights and distances from start and saves it to global arrays.
     * Default number -1 puts out special data which are saved in the "Final"-Arrays above.
     * Method tourPlanerTime calculates the right time in h:min format.
     * Tests are in attached excel file.
     * This is a collaboration work.
     * @param height
     * @param distanceFromStart
     * @param horizontalSpeed
     * @return
     */
    public static double getData (int height, double distanceFromStart, double horizontalSpeed) {
        System.out.print("Number of places: ");
        places = scanner.nextInt();
        String namePlace = null;

        if (places > 0) {
            for (int i = 1; i <= places; i++) {
                System.out.println(i + ". Place"); //1. Place:...

                System.out.printf("   Name \t\t\t\t\t\t: ");
                namePlace = scanner.next();
                namePlaceData[i - 1] = namePlace;

                System.out.printf("   Height [m] \t\t\t\t\t: ");
                height = scanner.nextInt();
                heightData[i - 1] = height;

                System.out.printf("   Distance from start [km] \t: ");
                distanceFromStart = scanner.nextDouble();
                distanceFromStartData[i - 1] = distanceFromStart;
            }
            System.out.println();
            System.out.printf("Upward speed [m/h] \t\t\t: ");
            verticalUpwardSpeed = scanner.nextInt();

            System.out.printf("Downward speed [m/h] \t\t: ");
            verticalDownwardSpeed = scanner.nextInt();

            System.out.printf("Horizontal speed [km/h] \t: ");
            horizontalSpeed = scanner.nextInt();
        } else if (places == -1) {
            places = 5;
            for (int i = 0; i < places; i++) {
                namePlaceData[i] = namePlaceDataFinal[i];
                heightData[i] = heightDataFinal[i];
                distanceFromStartData[i] = distanceFromStartDataFinal[i];
            }
            System.out.println();
        }
        tourPlanerTime();
        // Tests to put out the arrays:
//        for (int i = 0; i < places; i++) {
//            System.out.print(namePlaceData[i] + "|");
//        }
//        System.out.println();
//        for (int i = 0; i < places; i++) {
//            System.out.print(heightData[i] + "|");
//        }
//        System.out.println();
//        for (int i = 0; i < places; i++) {
//            System.out.print(distanceFromStartData[i] + "|");
//        }
//        System.out.println();
        return 0;
    }

    public static void tourPlanerTime () {
        double horizontalTime = 0;
        double verticalTime = 0;
        double horizontalSum = 0;
        double verticalSum = 0;
        double time = 0;
        // 1. Step: Calculation of the horizontal time:
        for (int i = 1; places > i; i++) {
            horizontalTime = ( 1 / horizontalSpeed) * (distanceFromStartData[i] - distanceFromStartData[i-1]);
            horizontalSum += horizontalTime;
            horizontalTimeData[i] = horizontalSum;
        }
        // 2. Step: Calculation of the vertical time:
        for (int i = 1; places > i; i++) {
            double heightDifference = heightData[i] - heightData[i-1];
            if (heightDifference > 0) {
                verticalTime = heightDifference * (1/verticalUpwardSpeed);
            } else {
                verticalTime = (( 1 / verticalDownwardSpeed) * (-1) * heightDifference);
            }
            verticalSum += verticalTime;
            verticalTimeData[i] = verticalSum;
        }
        // 3. Step: Calculation of total time:
        for (int i = 1; places > i; i++) {
            if (horizontalTimeData[i] > verticalTimeData[i]) {
                timeData[i] = verticalTimeData[i]/2 + horizontalTimeData[i];
            } else {
                timeData[i] = horizontalTimeData[i]/2 + verticalTimeData[i];
            }
        }
        // 4. Step: Conversion into hours and minutes:
        for (int i = 1; places > i; i++) {
            hoursData[i] = (int) timeData[i];
            minutesData[i] = (timeData[i] % 1) * 60;
        }
        // 5. Output of times:
        for (int i = 0; places > i; i++) {
            System.out.print(namePlaceData[i] + ": ");
            System.out.printf(hoursData[i] + ":%.0f", minutesData[i]);
            System.out.println();
        }
        System.out.println();
    }
}
